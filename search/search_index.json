{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"api/","title":"API Reference","text":"<p>Here's the reference or code API, the classes, functions, parameters, attributes, and all the BioExperiment Suite parts you can use in your applications.</p> <p>If you are looking for a specific part of the API, you can use the search bar at the top of the page.</p> <p>To learn how to use the API, you can check the examples page.</p>"},{"location":"api/tools/","title":"Helper functions for working with COM peripheral devices","text":""},{"location":"api/tools/#src.bioexperiment_suite.tools.serial_port.get_serial_ports","title":"<code>get_serial_ports()</code>","text":"<p>Lists serial port names on the system.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>A list of the serial ports available on the system</p> <p>Raises:</p> Type Description <code>EnvironmentError</code> <p>On unsupported or unknown platforms</p> Source code in <code>src/bioexperiment_suite/tools/serial_port.py</code> <pre><code>def get_serial_ports() -&gt; list[str]:\n    \"\"\"Lists serial port names on the system.\n\n    :returns: A list of the serial ports available on the system\n\n    :raises EnvironmentError: On unsupported or unknown platforms\n    \"\"\"\n    if sys.platform.startswith(\"win\"):\n        logger.info(\"Windows platform detected\")\n        ports = [f\"COM{i + 1}\" for i in range(256)]\n    elif sys.platform.startswith(\"linux\") or sys.platform.startswith(\"cygwin\"):\n        logger.info(\"Linux platform detected\")\n        # this excludes your current terminal \"/dev/tty\"\n        ports = glob.glob(\"/dev/tty[A-Za-z]*\")\n    elif sys.platform.startswith(\"darwin\"):\n        logger.info(\"MacOS platform detected\")\n        ports = glob.glob(\"/dev/tty.*\")\n    else:\n        logger.error(f\"Unsupported platform: {sys.platform}\")\n        raise EnvironmentError(\"Unsupported platform\")\n\n    result = []\n    for port in ports:\n        try:\n            s = serial.Serial(port)\n            s.close()\n            result.append(port)\n        except (OSError, serial.SerialException):\n            pass\n\n    logger.debug(f\"Serial ports found: {result}\")\n    return result\n</code></pre>"},{"location":"api/tools/#src.bioexperiment_suite.tools.devices.identify_device","title":"<code>identify_device(port)</code>","text":"<p>Identifies the device connected to the specified serial port.</p> <p>Parameters:</p> Name Type Description Default <code>port</code> <code>str</code> <p>The serial port name to identify the device connected to</p> required <p>Returns:</p> Type Description <code>str | None</code> <p>The device name of the device connected to the specified serial port, None otherwise</p> Source code in <code>src/bioexperiment_suite/tools/devices.py</code> <pre><code>def identify_device(port: str) -&gt; str | None:\n    \"\"\"Identifies the device connected to the specified serial port.\n\n    :param port: The serial port name to identify the device connected to\n\n    :returns: The device name of the device connected to the specified serial port, None otherwise\n    \"\"\"\n    serial_connection = SerialConnection(port)\n    for device_name, device_interface in device_interfaces.items():\n        logger.debug(f'Checking for device \"{device_interface.type}\" on port {port}')\n        logger.debug(f\"Identification signal: {device_interface.identification_signal}\")\n        response = serial_connection.communicate_with_serial_port(\n            device_interface.identification_signal, device_interface.identification_response_len\n        )\n\n        if len(response) == device_interface.identification_response_len and list(response)[0] == int(\n            device_interface.first_identification_response_byte\n        ):\n            logger.success(f'Device \"{device_interface.type}\" identified on port {port}')\n            return device_name\n\n    logger.warning(f\"No device identified on port {port}\")\n    return None\n</code></pre>"},{"location":"api/tools/#src.bioexperiment_suite.tools.devices.get_connected_devices","title":"<code>get_connected_devices()</code>","text":"<p>Identifies the devices connected to the serial ports on the system.</p> <p>Returns:</p> Type Description <code>tuple[list[Pump], list[Spectrophotometer]]</code> <p>A tuple containing the list of connected pumps and spectrophotometers</p> Source code in <code>src/bioexperiment_suite/tools/devices.py</code> <pre><code>def get_connected_devices() -&gt; tuple[list[Pump], list[Spectrophotometer]]:\n    \"\"\"Identifies the devices connected to the serial ports on the system.\n\n    :returns: A tuple containing the list of connected pumps and spectrophotometers\n    \"\"\"\n    serial_ports = get_serial_ports()\n    pump_list = []\n    spectrophotometer_list = []\n    for port in serial_ports:\n        device = identify_device(port)\n\n        match device:\n            case \"pump\":\n                pump = Pump(port)\n                pump_list.append(pump)\n            case \"spectrophotometer\":\n                spectrophotometer = Spectrophotometer(port)\n                spectrophotometer_list.append(spectrophotometer)\n\n    return pump_list, spectrophotometer_list\n</code></pre>"},{"location":"api/experiment/","title":"Experiment","text":"<p>This module provides the class for creating and running biological experiments. An experiment is a sequence of actions including:</p> <ul> <li>Actions (e.g. pump liquid)</li> <li>Measurements (e.g. measure absorbance)</li> <li>Waiting (wait for a certain amount of time)</li> </ul> <p>After setting up an experiment, you can run it and the BioExperiment Suite will execute the actions in the order you specified. Then you can analyze the results.</p>"},{"location":"api/experiment/actions/","title":"Actions","text":""},{"location":"api/experiment/actions/#src.bioexperiment_suite.experiment.experiment.Action","title":"<code>Action</code>","text":"<p>Class to define an action to be executed in an experiment.</p> <p>The action can be executed with the <code>execute</code> method, which will call the function with the provided arguments. The action keeps track of the time it was started and completed.</p> Source code in <code>src/bioexperiment_suite/experiment/experiment.py</code> <pre><code>class Action:\n    \"\"\"Class to define an action to be executed in an experiment.\n\n    The action can be executed with the `execute` method, which will call the function with the provided arguments.\n    The action keeps track of the time it was started and completed.\n    \"\"\"\n\n    def __init__(self, func: Callable, *args: Any, **kwargs: Any) -&gt; None:\n        \"\"\"Initialize the action with the function to be executed and the arguments to be passed to it.\n\n        :param func: The function to be executed\n        :param args: The positional arguments to be passed to the function\n        :param kwargs: The keyword arguments to be passed to the function\n        \"\"\"\n        self.func = func\n        self.args = args\n        self.kwargs = kwargs\n        self.start_time: datetime | None = None\n        self.end_time: datetime | None = None\n        logger.debug(f\"Action created: {self.func.__name__} with args: {args} and kwargs: {kwargs}\")\n\n    def execute(self) -&gt; None:\n        \"\"\"Execute the action by calling the function with the provided arguments and tracking the start and end time.\"\"\"\n        self.start_time = datetime.now()\n        logger.debug(f\"Executing action: {self.func.__name__}\")\n        self.func(*self.args, **self.kwargs)\n        self.end_time = datetime.now()\n        logger.debug(f\"Action completed: {self.func.__name__}\")\n\n    def is_completed(self) -&gt; bool:\n        \"\"\"Check if the action has been completed.\n\n        :return: True if the action has been completed, False otherwise\n        \"\"\"\n        return self.end_time is not None and self.start_time is not None\n\n    def duration(self) -&gt; timedelta:\n        \"\"\"Get the duration of the action.\n\n        :return: The duration of the action as a timedelta\n\n        :raises ValueError: If the action has not been completed yet\n        \"\"\"\n        if not self.is_completed():\n            raise ValueError(\"Action did not complete yet\")\n\n        return self.end_time - self.start_time  # type: ignore\n</code></pre>"},{"location":"api/experiment/actions/#src.bioexperiment_suite.experiment.experiment.Action.__init__","title":"<code>__init__(func, *args, **kwargs)</code>","text":"<p>Initialize the action with the function to be executed and the arguments to be passed to it.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable</code> <p>The function to be executed</p> required <code>args</code> <code>Any</code> <p>The positional arguments to be passed to the function</p> <code>()</code> <code>kwargs</code> <code>Any</code> <p>The keyword arguments to be passed to the function</p> <code>{}</code> Source code in <code>src/bioexperiment_suite/experiment/experiment.py</code> <pre><code>def __init__(self, func: Callable, *args: Any, **kwargs: Any) -&gt; None:\n    \"\"\"Initialize the action with the function to be executed and the arguments to be passed to it.\n\n    :param func: The function to be executed\n    :param args: The positional arguments to be passed to the function\n    :param kwargs: The keyword arguments to be passed to the function\n    \"\"\"\n    self.func = func\n    self.args = args\n    self.kwargs = kwargs\n    self.start_time: datetime | None = None\n    self.end_time: datetime | None = None\n    logger.debug(f\"Action created: {self.func.__name__} with args: {args} and kwargs: {kwargs}\")\n</code></pre>"},{"location":"api/experiment/actions/#src.bioexperiment_suite.experiment.experiment.Action.execute","title":"<code>execute()</code>","text":"<p>Execute the action by calling the function with the provided arguments and tracking the start and end time.</p> Source code in <code>src/bioexperiment_suite/experiment/experiment.py</code> <pre><code>def execute(self) -&gt; None:\n    \"\"\"Execute the action by calling the function with the provided arguments and tracking the start and end time.\"\"\"\n    self.start_time = datetime.now()\n    logger.debug(f\"Executing action: {self.func.__name__}\")\n    self.func(*self.args, **self.kwargs)\n    self.end_time = datetime.now()\n    logger.debug(f\"Action completed: {self.func.__name__}\")\n</code></pre>"},{"location":"api/experiment/actions/#src.bioexperiment_suite.experiment.experiment.Action.is_completed","title":"<code>is_completed()</code>","text":"<p>Check if the action has been completed.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the action has been completed, False otherwise</p> Source code in <code>src/bioexperiment_suite/experiment/experiment.py</code> <pre><code>def is_completed(self) -&gt; bool:\n    \"\"\"Check if the action has been completed.\n\n    :return: True if the action has been completed, False otherwise\n    \"\"\"\n    return self.end_time is not None and self.start_time is not None\n</code></pre>"},{"location":"api/experiment/actions/#src.bioexperiment_suite.experiment.experiment.Action.duration","title":"<code>duration()</code>","text":"<p>Get the duration of the action.</p> <p>Returns:</p> Type Description <code>timedelta</code> <p>The duration of the action as a timedelta</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the action has not been completed yet</p> Source code in <code>src/bioexperiment_suite/experiment/experiment.py</code> <pre><code>def duration(self) -&gt; timedelta:\n    \"\"\"Get the duration of the action.\n\n    :return: The duration of the action as a timedelta\n\n    :raises ValueError: If the action has not been completed yet\n    \"\"\"\n    if not self.is_completed():\n        raise ValueError(\"Action did not complete yet\")\n\n    return self.end_time - self.start_time  # type: ignore\n</code></pre>"},{"location":"api/experiment/actions/#src.bioexperiment_suite.experiment.experiment.Measurement","title":"<code>Measurement</code>","text":"<p>               Bases: <code>Action</code></p> <p>Class to define a measurement to be executed in an experiment.</p> <p>The measurement is a special type of action that also stores the measured value name and the measurement result.</p> Source code in <code>src/bioexperiment_suite/experiment/experiment.py</code> <pre><code>class Measurement(Action):\n    \"\"\"Class to define a measurement to be executed in an experiment.\n\n    The measurement is a special type of action that also stores the measured value name and the measurement result.\n    \"\"\"\n\n    def __init__(self, func: Callable, measurement_name: str, *args: Any, **kwargs: Any):\n        \"\"\"Initialize the measurement with the function to be executed, the measured value name, and the arguments.\n\n        :param func: The function to be executed\n        :param measurement_name: The name of the measured value\n        :param args: The positional arguments to be passed to the function\n        :param kwargs: The keyword arguments to be passed to the function\n        \"\"\"\n        super().__init__(func, *args, **kwargs)\n        self.measurement_name = measurement_name\n        self.measured_value = None\n        logger.debug(f\"Measurement created: {self.func.__name__} with args: {args} and kwargs: {kwargs}\")\n\n    def execute(self) -&gt; Any:\n        \"\"\"Execute the measurement by calling the function with the provided arguments and tracking the start and end time.\n\n        :return: The result of the measurement\n        \"\"\"\n        assert self.start_time is None, \"Measurement already executed\"\n        self.start_time = datetime.now()\n        logger.debug(f\"Executing measurement: {self.func.__name__}\")\n        result = self.func(*self.args, **self.kwargs)\n        self.end_time = datetime.now()\n        self.measured_value = result\n        logger.debug(f\"Measurement completed: {self.func.__name__}\")\n        return result\n</code></pre>"},{"location":"api/experiment/actions/#src.bioexperiment_suite.experiment.experiment.Measurement.__init__","title":"<code>__init__(func, measurement_name, *args, **kwargs)</code>","text":"<p>Initialize the measurement with the function to be executed, the measured value name, and the arguments.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable</code> <p>The function to be executed</p> required <code>measurement_name</code> <code>str</code> <p>The name of the measured value</p> required <code>args</code> <code>Any</code> <p>The positional arguments to be passed to the function</p> <code>()</code> <code>kwargs</code> <code>Any</code> <p>The keyword arguments to be passed to the function</p> <code>{}</code> Source code in <code>src/bioexperiment_suite/experiment/experiment.py</code> <pre><code>def __init__(self, func: Callable, measurement_name: str, *args: Any, **kwargs: Any):\n    \"\"\"Initialize the measurement with the function to be executed, the measured value name, and the arguments.\n\n    :param func: The function to be executed\n    :param measurement_name: The name of the measured value\n    :param args: The positional arguments to be passed to the function\n    :param kwargs: The keyword arguments to be passed to the function\n    \"\"\"\n    super().__init__(func, *args, **kwargs)\n    self.measurement_name = measurement_name\n    self.measured_value = None\n    logger.debug(f\"Measurement created: {self.func.__name__} with args: {args} and kwargs: {kwargs}\")\n</code></pre>"},{"location":"api/experiment/actions/#src.bioexperiment_suite.experiment.experiment.Measurement.execute","title":"<code>execute()</code>","text":"<p>Execute the measurement by calling the function with the provided arguments and tracking the start and end time.</p> <p>Returns:</p> Type Description <code>Any</code> <p>The result of the measurement</p> Source code in <code>src/bioexperiment_suite/experiment/experiment.py</code> <pre><code>def execute(self) -&gt; Any:\n    \"\"\"Execute the measurement by calling the function with the provided arguments and tracking the start and end time.\n\n    :return: The result of the measurement\n    \"\"\"\n    assert self.start_time is None, \"Measurement already executed\"\n    self.start_time = datetime.now()\n    logger.debug(f\"Executing measurement: {self.func.__name__}\")\n    result = self.func(*self.args, **self.kwargs)\n    self.end_time = datetime.now()\n    self.measured_value = result\n    logger.debug(f\"Measurement completed: {self.func.__name__}\")\n    return result\n</code></pre>"},{"location":"api/experiment/actions/#src.bioexperiment_suite.experiment.experiment.WaitAction","title":"<code>WaitAction</code>","text":"<p>Class to define a wait action to be executed in an experiment.</p> <p>The wait action is a special type of action that pauses the execution of the experiment for a given amount of time. If some action takes time to be executed, the wait time should be not less than the time taken by the action.</p> Source code in <code>src/bioexperiment_suite/experiment/experiment.py</code> <pre><code>class WaitAction:\n    \"\"\"Class to define a wait action to be executed in an experiment.\n\n    The wait action is a special type of action that pauses the execution of the experiment for a given amount of time.\n    If some action takes time to be executed, the wait time should be not less than the time taken by the action.\n    \"\"\"\n\n    def __init__(self, seconds: float):\n        \"\"\"Initialize the wait action with the number of seconds to wait.\n\n        :param seconds: The number of seconds to wait\n        \"\"\"\n        self.wait_time: timedelta = timedelta(seconds=seconds)\n        logger.debug(f\"Wait action created: {seconds} seconds\")\n</code></pre>"},{"location":"api/experiment/actions/#src.bioexperiment_suite.experiment.experiment.WaitAction.__init__","title":"<code>__init__(seconds)</code>","text":"<p>Initialize the wait action with the number of seconds to wait.</p> <p>Parameters:</p> Name Type Description Default <code>seconds</code> <code>float</code> <p>The number of seconds to wait</p> required Source code in <code>src/bioexperiment_suite/experiment/experiment.py</code> <pre><code>def __init__(self, seconds: float):\n    \"\"\"Initialize the wait action with the number of seconds to wait.\n\n    :param seconds: The number of seconds to wait\n    \"\"\"\n    self.wait_time: timedelta = timedelta(seconds=seconds)\n    logger.debug(f\"Wait action created: {seconds} seconds\")\n</code></pre>"},{"location":"api/experiment/experiment/","title":"Experiment","text":""},{"location":"api/experiment/experiment/#src.bioexperiment_suite.experiment.experiment.Experiment","title":"<code>Experiment</code>","text":"<p>Class to define an experiment with actions and measurements to be executed in sequence.</p> <p>The experiment can be run with the <code>run</code> method, which will execute each action in sequence. The experiment keeps track of the time each action was executed and the measurements taken.</p> Source code in <code>src/bioexperiment_suite/experiment/experiment.py</code> <pre><code>class Experiment:\n    \"\"\"Class to define an experiment with actions and measurements to be executed in sequence.\n\n    The experiment can be run with the `run` method, which will execute each action in sequence.\n    The experiment keeps track of the time each action was executed and the measurements taken.\n    \"\"\"\n\n    def __init__(self, output_dir: os.PathLike | None = None):\n        \"\"\"Initialize the experiment with an empty list of actions and measurements\"\"\"\n        self.actions: list[Action | WaitAction] = []\n        self.measurements: dict[str, list[tuple[datetime, Any]]] = defaultdict(list)\n        self.current_time: datetime | None = (\n            None  # Time to keep track of the experiment progress. Initializes on start.\n        )\n        self.output_dir = output_dir\n        self._thread: Thread | None = None\n        self._stop_event = Event()\n        logger.debug(\"Experiment created\")\n\n    def specify_output_dir(self, output_dir: os.PathLike):\n        \"\"\"Specify the output directory to write measurements to CSV files.\n\n        :param output_dir: The directory to write measurements to\n        \"\"\"\n        self.output_dir = output_dir\n        logger.debug(f\"Output directory specified: {output_dir}\")\n\n    def add_action(self, func: Callable, *args: Any, **kwargs: Any):\n        \"\"\"Add an action to the experiment.\n\n        The action will be executed in sequence when the experiment is run.\n\n        :param func: The function to be executed\n        :param args: The positional arguments to be passed to the function\n        :param kwargs: The keyword arguments to be passed to the function\n        \"\"\"\n        self._validate_types(func, *args, **kwargs)\n        self.actions.append(Action(func, *args, **kwargs))\n        logger.debug(f\"Action added to experiment: {func.__name__}\")\n\n    def add_measurement(self, func: Callable, measurement_name: str, *args: Any, **kwargs: Any):\n        \"\"\"Add a measurement to the experiment.\n\n        The measurement will be executed in sequence when the experiment is run, and the result will be stored.\n\n        :param func: The function to be executed\n        :param measurement_name: The name of the measured value\n        :param args: The positional arguments to be passed to the function\n        :param kwargs: The keyword arguments to be passed to the function\n        \"\"\"\n        self._validate_types(func, *args, **kwargs)\n        self.actions.append(Measurement(func, measurement_name, *args, **kwargs))\n        logger.debug(f\"Measurement added to experiment: {func.__name__}\")\n\n    def add_wait(self, seconds: float):\n        \"\"\"Add a wait action to the experiment.\n\n        The wait action will pause the execution of the experiment for the given amount of time.\n\n        :param seconds: The number of seconds to wait\n        \"\"\"\n        self.actions.append(WaitAction(seconds))\n        logger.debug(f\"Wait action added to experiment: {seconds} seconds\")\n\n    def _run(self):\n        \"\"\"Run the experiment by executing each action in sequence.\"\"\"\n        self.current_time = datetime.now()\n        logger.debug(f\"Experiment started. Start time: {self.current_time}\")\n        for step, action in enumerate(self.actions):\n            logger.debug(f\"Step {step + 1} from {len(self.actions)}\")\n            if isinstance(action, Measurement):\n                logger.debug(f\"Executing measurement: {action.func.__name__}\")\n                action.execute()\n                self.measurements[action.measurement_name].append((datetime.now(), action.measured_value))\n                self.write_measurement_to_csv(action.measurement_name)\n            elif isinstance(action, Action):\n                logger.debug(f\"Executing action: {action.func.__name__}\")\n                action.execute()\n            elif isinstance(action, WaitAction):\n                wait_until = self.current_time + action.wait_time\n                logger.debug(f\"Waiting for {action.wait_time.total_seconds()} seconds from {self.current_time}\")\n\n                if datetime.now() &gt; wait_until:\n                    logger.warning(f\"Wait time exceeded on step {step + 1} by {datetime.now() - wait_until}\")\n\n                while datetime.now() &lt; wait_until:\n                    if self._stop_event.is_set():\n                        logger.debug(\"Experiment stopped\")\n                        return\n                    time.sleep(0.1)\n\n                self.current_time += action.wait_time\n\n            else:\n                logger.error(f\"Unknown action type: {type(action)}\")\n                raise ValueError(f\"Unknown action type: {type(action)}\")\n\n    def start(self, start_in_background: bool = True):\n        \"\"\"Start the experiment by running it in a separate thread.\n\n        :param start_in_background: If True, start the experiment in a separate thread.\n        If False, run the experiment in the current thread. Be careful with this option,\n        as it will block the current thread until the experiment is finished!\n        \"\"\"\n        if self._thread is not None:\n            logger.warning(\"Experiment is already running\")\n            return\n\n        self._stop_event.clear()\n        if start_in_background:\n            self._thread = Thread(target=self._run)\n            self._thread.start()\n        else:\n            self._run()\n\n    def stop(self):\n        \"\"\"Stop the experiment by setting the stop event.\"\"\"\n        if self._thread is None:\n            logger.warning(\"Experiment is not running\")\n            return\n        self._stop_event.set()\n        logger.info(\"Experiment stop signal sent\")\n\n    def write_measurement_to_csv(self, measurement_name: str):\n        \"\"\"Write last acquired measurement to a CSV file.\n\n        :param measurement_name: The name of the measurement to write to a CSV file\n        \"\"\"\n        if self.output_dir is None:\n            return\n\n        if measurement_name not in self.measurements:\n            raise ValueError(f\"Measurement '{measurement_name}' not found\")\n\n        output_file = os.path.join(self.output_dir, f\"{measurement_name}.csv\")\n        with open(output_file, \"a\") as f:\n            timestamp, value = self.measurements[measurement_name][-1]\n            f.write(f\"{timestamp},{value}\\n\")\n\n        logger.debug(f\"Measurement '{measurement_name}' written to {output_file}\")\n\n    def reset_experiment(self):\n        \"\"\"Reset the experiment by clearing the actions, measurements and current time.\"\"\"\n        logger.debug(\"Experiment reset\")\n        if self._thread is not None:\n            logger.warning(\"Experiment is running. Stop it before resetting.\")\n            return\n\n        self.actions.clear()\n        self.measurements.clear()\n        self.current_time = None\n\n    def _validate_types(self, func: Callable, *args: Any, **kwargs: Any):\n        \"\"\"Validate that the arguments passed to the function are of the correct type.\n\n        :param func: The function to validate the arguments for\n        :param args: The positional arguments to validate\n        :param kwargs: The keyword arguments to validate\n\n        :raises TypeError: If any argument is not of the expected type according to the type hints of the function\n        \"\"\"\n        type_hints = get_type_hints(func)\n        sig = inspect.signature(func)\n        bound_arguments = sig.bind_partial(*args, **kwargs).arguments\n\n        for name, value in bound_arguments.items():\n            expected_type = type_hints.get(name)\n            if expected_type and not isinstance(value, expected_type):\n                msg = f\"Argument '{name}' is expected to be of type {expected_type}, but got {type(value)}\"\n                raise TypeError(msg)\n</code></pre>"},{"location":"api/experiment/experiment/#src.bioexperiment_suite.experiment.experiment.Experiment.__init__","title":"<code>__init__(output_dir=None)</code>","text":"<p>Initialize the experiment with an empty list of actions and measurements</p> Source code in <code>src/bioexperiment_suite/experiment/experiment.py</code> <pre><code>def __init__(self, output_dir: os.PathLike | None = None):\n    \"\"\"Initialize the experiment with an empty list of actions and measurements\"\"\"\n    self.actions: list[Action | WaitAction] = []\n    self.measurements: dict[str, list[tuple[datetime, Any]]] = defaultdict(list)\n    self.current_time: datetime | None = (\n        None  # Time to keep track of the experiment progress. Initializes on start.\n    )\n    self.output_dir = output_dir\n    self._thread: Thread | None = None\n    self._stop_event = Event()\n    logger.debug(\"Experiment created\")\n</code></pre>"},{"location":"api/experiment/experiment/#src.bioexperiment_suite.experiment.experiment.Experiment.specify_output_dir","title":"<code>specify_output_dir(output_dir)</code>","text":"<p>Specify the output directory to write measurements to CSV files.</p> <p>Parameters:</p> Name Type Description Default <code>output_dir</code> <code>PathLike</code> <p>The directory to write measurements to</p> required Source code in <code>src/bioexperiment_suite/experiment/experiment.py</code> <pre><code>def specify_output_dir(self, output_dir: os.PathLike):\n    \"\"\"Specify the output directory to write measurements to CSV files.\n\n    :param output_dir: The directory to write measurements to\n    \"\"\"\n    self.output_dir = output_dir\n    logger.debug(f\"Output directory specified: {output_dir}\")\n</code></pre>"},{"location":"api/experiment/experiment/#src.bioexperiment_suite.experiment.experiment.Experiment.add_action","title":"<code>add_action(func, *args, **kwargs)</code>","text":"<p>Add an action to the experiment.</p> <p>The action will be executed in sequence when the experiment is run.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable</code> <p>The function to be executed</p> required <code>args</code> <code>Any</code> <p>The positional arguments to be passed to the function</p> <code>()</code> <code>kwargs</code> <code>Any</code> <p>The keyword arguments to be passed to the function</p> <code>{}</code> Source code in <code>src/bioexperiment_suite/experiment/experiment.py</code> <pre><code>def add_action(self, func: Callable, *args: Any, **kwargs: Any):\n    \"\"\"Add an action to the experiment.\n\n    The action will be executed in sequence when the experiment is run.\n\n    :param func: The function to be executed\n    :param args: The positional arguments to be passed to the function\n    :param kwargs: The keyword arguments to be passed to the function\n    \"\"\"\n    self._validate_types(func, *args, **kwargs)\n    self.actions.append(Action(func, *args, **kwargs))\n    logger.debug(f\"Action added to experiment: {func.__name__}\")\n</code></pre>"},{"location":"api/experiment/experiment/#src.bioexperiment_suite.experiment.experiment.Experiment.add_measurement","title":"<code>add_measurement(func, measurement_name, *args, **kwargs)</code>","text":"<p>Add a measurement to the experiment.</p> <p>The measurement will be executed in sequence when the experiment is run, and the result will be stored.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable</code> <p>The function to be executed</p> required <code>measurement_name</code> <code>str</code> <p>The name of the measured value</p> required <code>args</code> <code>Any</code> <p>The positional arguments to be passed to the function</p> <code>()</code> <code>kwargs</code> <code>Any</code> <p>The keyword arguments to be passed to the function</p> <code>{}</code> Source code in <code>src/bioexperiment_suite/experiment/experiment.py</code> <pre><code>def add_measurement(self, func: Callable, measurement_name: str, *args: Any, **kwargs: Any):\n    \"\"\"Add a measurement to the experiment.\n\n    The measurement will be executed in sequence when the experiment is run, and the result will be stored.\n\n    :param func: The function to be executed\n    :param measurement_name: The name of the measured value\n    :param args: The positional arguments to be passed to the function\n    :param kwargs: The keyword arguments to be passed to the function\n    \"\"\"\n    self._validate_types(func, *args, **kwargs)\n    self.actions.append(Measurement(func, measurement_name, *args, **kwargs))\n    logger.debug(f\"Measurement added to experiment: {func.__name__}\")\n</code></pre>"},{"location":"api/experiment/experiment/#src.bioexperiment_suite.experiment.experiment.Experiment.add_wait","title":"<code>add_wait(seconds)</code>","text":"<p>Add a wait action to the experiment.</p> <p>The wait action will pause the execution of the experiment for the given amount of time.</p> <p>Parameters:</p> Name Type Description Default <code>seconds</code> <code>float</code> <p>The number of seconds to wait</p> required Source code in <code>src/bioexperiment_suite/experiment/experiment.py</code> <pre><code>def add_wait(self, seconds: float):\n    \"\"\"Add a wait action to the experiment.\n\n    The wait action will pause the execution of the experiment for the given amount of time.\n\n    :param seconds: The number of seconds to wait\n    \"\"\"\n    self.actions.append(WaitAction(seconds))\n    logger.debug(f\"Wait action added to experiment: {seconds} seconds\")\n</code></pre>"},{"location":"api/experiment/experiment/#src.bioexperiment_suite.experiment.experiment.Experiment.start","title":"<code>start(start_in_background=True)</code>","text":"<p>Start the experiment by running it in a separate thread.</p> <p>Parameters:</p> Name Type Description Default <code>start_in_background</code> <code>bool</code> <p>If True, start the experiment in a separate thread. If False, run the experiment in the current thread. Be careful with this option, as it will block the current thread until the experiment is finished!</p> <code>True</code> Source code in <code>src/bioexperiment_suite/experiment/experiment.py</code> <pre><code>def start(self, start_in_background: bool = True):\n    \"\"\"Start the experiment by running it in a separate thread.\n\n    :param start_in_background: If True, start the experiment in a separate thread.\n    If False, run the experiment in the current thread. Be careful with this option,\n    as it will block the current thread until the experiment is finished!\n    \"\"\"\n    if self._thread is not None:\n        logger.warning(\"Experiment is already running\")\n        return\n\n    self._stop_event.clear()\n    if start_in_background:\n        self._thread = Thread(target=self._run)\n        self._thread.start()\n    else:\n        self._run()\n</code></pre>"},{"location":"api/experiment/experiment/#src.bioexperiment_suite.experiment.experiment.Experiment.stop","title":"<code>stop()</code>","text":"<p>Stop the experiment by setting the stop event.</p> Source code in <code>src/bioexperiment_suite/experiment/experiment.py</code> <pre><code>def stop(self):\n    \"\"\"Stop the experiment by setting the stop event.\"\"\"\n    if self._thread is None:\n        logger.warning(\"Experiment is not running\")\n        return\n    self._stop_event.set()\n    logger.info(\"Experiment stop signal sent\")\n</code></pre>"},{"location":"api/experiment/experiment/#src.bioexperiment_suite.experiment.experiment.Experiment.write_measurement_to_csv","title":"<code>write_measurement_to_csv(measurement_name)</code>","text":"<p>Write last acquired measurement to a CSV file.</p> <p>Parameters:</p> Name Type Description Default <code>measurement_name</code> <code>str</code> <p>The name of the measurement to write to a CSV file</p> required Source code in <code>src/bioexperiment_suite/experiment/experiment.py</code> <pre><code>def write_measurement_to_csv(self, measurement_name: str):\n    \"\"\"Write last acquired measurement to a CSV file.\n\n    :param measurement_name: The name of the measurement to write to a CSV file\n    \"\"\"\n    if self.output_dir is None:\n        return\n\n    if measurement_name not in self.measurements:\n        raise ValueError(f\"Measurement '{measurement_name}' not found\")\n\n    output_file = os.path.join(self.output_dir, f\"{measurement_name}.csv\")\n    with open(output_file, \"a\") as f:\n        timestamp, value = self.measurements[measurement_name][-1]\n        f.write(f\"{timestamp},{value}\\n\")\n\n    logger.debug(f\"Measurement '{measurement_name}' written to {output_file}\")\n</code></pre>"},{"location":"api/experiment/experiment/#src.bioexperiment_suite.experiment.experiment.Experiment.reset_experiment","title":"<code>reset_experiment()</code>","text":"<p>Reset the experiment by clearing the actions, measurements and current time.</p> Source code in <code>src/bioexperiment_suite/experiment/experiment.py</code> <pre><code>def reset_experiment(self):\n    \"\"\"Reset the experiment by clearing the actions, measurements and current time.\"\"\"\n    logger.debug(\"Experiment reset\")\n    if self._thread is not None:\n        logger.warning(\"Experiment is running. Stop it before resetting.\")\n        return\n\n    self.actions.clear()\n    self.measurements.clear()\n    self.current_time = None\n</code></pre>"},{"location":"api/interfaces/","title":"Interfaces","text":"<p>This module provides the interfaces for hardware devices that can be controlled by the BioExperiment Suite. Using these interfaces, you can interact with the devices in a standardized way, regardless of the specific hardware implementation.</p>"},{"location":"api/interfaces/pump/","title":"Pump","text":""},{"location":"api/interfaces/pump/#src.bioexperiment_suite.interfaces.pump.Pump","title":"<code>Pump</code>","text":"<p>               Bases: <code>SerialConnection</code></p> <p>Class to handle communication with a pump connected to a serial port.</p> Source code in <code>src/bioexperiment_suite/interfaces/pump.py</code> <pre><code>class Pump(SerialConnection):\n    \"\"\"Class to handle communication with a pump connected to a serial port.\"\"\"\n\n    def __init__(self, port: str, baudrate: int = 9600, timeout_sec: int | float = 1.0):\n        \"\"\"Initializes the pump object.\n\n        :param port: The serial port to connect to\n        :param baudrate: The baudrate of the serial connection. Defaults to 9600\n        :param timeout_sec: The timeout of the serial connection to respond in seconds. Defaults to 1.0\n        \"\"\"\n        self.interface = device_interfaces.pump\n        self.default_flow_rate: int | float | None = None\n        super(Pump, self).__init__(port, baudrate, timeout_sec)\n        self._compute_calibration_volume()\n\n    def _compute_calibration_volume(self):\n        \"\"\"Computes the calibration volume of the pump.\"\"\"\n        identification_response = self.communicate_with_serial_port(\n            self.interface.identification_signal,\n            self.interface.identification_response_len,\n        )\n        self._calibration_volume = self._bytes_to_int(identification_response[1:]) / 10**5\n        logger.debug(f\"Calibration volume computed: {self._calibration_volume:.3f}\")\n\n    def _compute_speed_param_from_flow(self, flow: int | float) -&gt; int:\n        \"\"\"Computes the speed parameter from the real speed of the pump.\n\n        :param flow: The real flow rate of the pump in mL/min\n\n        :returns: The speed parameter to send to the pump\n        \"\"\"\n\n        speed_param = int(29 / flow)\n        return speed_param\n\n    def _compute_step_volume_bytes(self, volume: int | float) -&gt; list[int]:\n        \"\"\"Computes the step volume in bytes to send to the pump.\n\n        :param volume: The volume to set in mL\n\n        :returns: The byte representation of the volume\n        \"\"\"\n        step_volume = int((volume * 10**4) / self._calibration_volume)\n        step_volume_bytes = self._int_to_bytes(step_volume, 4)\n        return step_volume_bytes\n\n    def set_default_flow_rate(self, flow_rate: int | float):\n        \"\"\"Sets the default flow rate of the pump.\n\n        :param flow_rate: The flow rate to set in mL/min\n        \"\"\"\n        self.default_flow_rate = flow_rate\n\n    def _set_flow_rate(self, flow_rate: int | float):\n        \"\"\"Sets the flow rate of the pump before pouring in volume.\n\n        :param flow_rate: The flow rate to set in mL/min\n        \"\"\"\n        logger.debug(f\"Setting flow rate to {flow_rate:.3f} mL/min\")\n        speed_param = self._compute_speed_param_from_flow(flow_rate)\n        data_to_send = [10, 0, 1, speed_param, 0]\n        self.write_to_serial_port(data_to_send)\n\n    def pour_in_volume(self, volume: int | float, flow_rate: int | float | None = None, direction: str = \"left\"):\n        \"\"\"Pours in the specified volume of liquid.\n\n        :param volume: The volume to pour in mL\n        :param flow_rate: The flow rate of the pump in mL/min\n        :param direction: The direction of the pump, either \"left\" or \"right\". Defaults to \"left\"\n        \"\"\"\n\n        assert direction in [\"left\", \"right\"], \"Invalid direction. Must be either 'left' or 'right'\"\n        direction_byte = 16 if direction == \"left\" else 17\n\n        if flow_rate is None and self.default_flow_rate is None:\n            raise ValueError(\"Flow rate must be set before pouring in volume or passed as an argument\")\n\n        flow_rate = flow_rate or self.default_flow_rate\n        self._set_flow_rate(flow_rate)  # type: ignore\n\n        logger.debug(f\"Pouring in {volume:.3f} mL at flow rate {flow_rate:.3f} mL/min\")\n\n        data_to_send = [direction_byte] + self._compute_step_volume_bytes(volume)\n        self.write_to_serial_port(data_to_send)\n\n    def start_continuous_rotation(self, flow_rate: int | float | None = None, direction: str = \"left\"):\n        \"\"\"Starts the continuous rotation of the pump.\n\n        :param flow_rate: The flow rate of the pump in mL/min\n        :param direction: The direction of the pump, either \"left\" or \"right\". Defaults to \"left\"\n        \"\"\"\n\n        assert direction in [\"left\", \"right\"], \"Invalid direction. Must be either 'left' or 'right'\"\n        direction_byte = 11 if direction == \"left\" else 12\n\n        if flow_rate is None and self.default_flow_rate is None:\n            raise ValueError(\"Flow rate must be set before starting continuous rotation or passed as an argument\")\n\n        flow_rate = flow_rate or self.default_flow_rate\n\n        logger.debug(f\"Starting continuous rotation at flow rate {flow_rate:.3f} mL/min\")\n        speed_param = self._compute_speed_param_from_flow(flow_rate)  # type: ignore\n\n        data_to_send = [direction_byte, 111, 1, speed_param, 0]\n        self.write_to_serial_port(data_to_send)\n\n    def stop_continuous_rotation(self):\n        \"\"\"Stops the continuous rotation of the pump\"\"\"\n        logger.debug(\"Stopping continuous rotation\")\n        self.pour_in_volume(0)\n</code></pre>"},{"location":"api/interfaces/pump/#src.bioexperiment_suite.interfaces.pump.Pump.__init__","title":"<code>__init__(port, baudrate=9600, timeout_sec=1.0)</code>","text":"<p>Initializes the pump object.</p> <p>Parameters:</p> Name Type Description Default <code>port</code> <code>str</code> <p>The serial port to connect to</p> required <code>baudrate</code> <code>int</code> <p>The baudrate of the serial connection. Defaults to 9600</p> <code>9600</code> <code>timeout_sec</code> <code>int | float</code> <p>The timeout of the serial connection to respond in seconds. Defaults to 1.0</p> <code>1.0</code> Source code in <code>src/bioexperiment_suite/interfaces/pump.py</code> <pre><code>def __init__(self, port: str, baudrate: int = 9600, timeout_sec: int | float = 1.0):\n    \"\"\"Initializes the pump object.\n\n    :param port: The serial port to connect to\n    :param baudrate: The baudrate of the serial connection. Defaults to 9600\n    :param timeout_sec: The timeout of the serial connection to respond in seconds. Defaults to 1.0\n    \"\"\"\n    self.interface = device_interfaces.pump\n    self.default_flow_rate: int | float | None = None\n    super(Pump, self).__init__(port, baudrate, timeout_sec)\n    self._compute_calibration_volume()\n</code></pre>"},{"location":"api/interfaces/pump/#src.bioexperiment_suite.interfaces.pump.Pump.set_default_flow_rate","title":"<code>set_default_flow_rate(flow_rate)</code>","text":"<p>Sets the default flow rate of the pump.</p> <p>Parameters:</p> Name Type Description Default <code>flow_rate</code> <code>int | float</code> <p>The flow rate to set in mL/min</p> required Source code in <code>src/bioexperiment_suite/interfaces/pump.py</code> <pre><code>def set_default_flow_rate(self, flow_rate: int | float):\n    \"\"\"Sets the default flow rate of the pump.\n\n    :param flow_rate: The flow rate to set in mL/min\n    \"\"\"\n    self.default_flow_rate = flow_rate\n</code></pre>"},{"location":"api/interfaces/pump/#src.bioexperiment_suite.interfaces.pump.Pump.pour_in_volume","title":"<code>pour_in_volume(volume, flow_rate=None, direction='left')</code>","text":"<p>Pours in the specified volume of liquid.</p> <p>Parameters:</p> Name Type Description Default <code>volume</code> <code>int | float</code> <p>The volume to pour in mL</p> required <code>flow_rate</code> <code>int | float | None</code> <p>The flow rate of the pump in mL/min</p> <code>None</code> <code>direction</code> <code>str</code> <p>The direction of the pump, either \"left\" or \"right\". Defaults to \"left\"</p> <code>'left'</code> Source code in <code>src/bioexperiment_suite/interfaces/pump.py</code> <pre><code>def pour_in_volume(self, volume: int | float, flow_rate: int | float | None = None, direction: str = \"left\"):\n    \"\"\"Pours in the specified volume of liquid.\n\n    :param volume: The volume to pour in mL\n    :param flow_rate: The flow rate of the pump in mL/min\n    :param direction: The direction of the pump, either \"left\" or \"right\". Defaults to \"left\"\n    \"\"\"\n\n    assert direction in [\"left\", \"right\"], \"Invalid direction. Must be either 'left' or 'right'\"\n    direction_byte = 16 if direction == \"left\" else 17\n\n    if flow_rate is None and self.default_flow_rate is None:\n        raise ValueError(\"Flow rate must be set before pouring in volume or passed as an argument\")\n\n    flow_rate = flow_rate or self.default_flow_rate\n    self._set_flow_rate(flow_rate)  # type: ignore\n\n    logger.debug(f\"Pouring in {volume:.3f} mL at flow rate {flow_rate:.3f} mL/min\")\n\n    data_to_send = [direction_byte] + self._compute_step_volume_bytes(volume)\n    self.write_to_serial_port(data_to_send)\n</code></pre>"},{"location":"api/interfaces/pump/#src.bioexperiment_suite.interfaces.pump.Pump.start_continuous_rotation","title":"<code>start_continuous_rotation(flow_rate=None, direction='left')</code>","text":"<p>Starts the continuous rotation of the pump.</p> <p>Parameters:</p> Name Type Description Default <code>flow_rate</code> <code>int | float | None</code> <p>The flow rate of the pump in mL/min</p> <code>None</code> <code>direction</code> <code>str</code> <p>The direction of the pump, either \"left\" or \"right\". Defaults to \"left\"</p> <code>'left'</code> Source code in <code>src/bioexperiment_suite/interfaces/pump.py</code> <pre><code>def start_continuous_rotation(self, flow_rate: int | float | None = None, direction: str = \"left\"):\n    \"\"\"Starts the continuous rotation of the pump.\n\n    :param flow_rate: The flow rate of the pump in mL/min\n    :param direction: The direction of the pump, either \"left\" or \"right\". Defaults to \"left\"\n    \"\"\"\n\n    assert direction in [\"left\", \"right\"], \"Invalid direction. Must be either 'left' or 'right'\"\n    direction_byte = 11 if direction == \"left\" else 12\n\n    if flow_rate is None and self.default_flow_rate is None:\n        raise ValueError(\"Flow rate must be set before starting continuous rotation or passed as an argument\")\n\n    flow_rate = flow_rate or self.default_flow_rate\n\n    logger.debug(f\"Starting continuous rotation at flow rate {flow_rate:.3f} mL/min\")\n    speed_param = self._compute_speed_param_from_flow(flow_rate)  # type: ignore\n\n    data_to_send = [direction_byte, 111, 1, speed_param, 0]\n    self.write_to_serial_port(data_to_send)\n</code></pre>"},{"location":"api/interfaces/pump/#src.bioexperiment_suite.interfaces.pump.Pump.stop_continuous_rotation","title":"<code>stop_continuous_rotation()</code>","text":"<p>Stops the continuous rotation of the pump</p> Source code in <code>src/bioexperiment_suite/interfaces/pump.py</code> <pre><code>def stop_continuous_rotation(self):\n    \"\"\"Stops the continuous rotation of the pump\"\"\"\n    logger.debug(\"Stopping continuous rotation\")\n    self.pour_in_volume(0)\n</code></pre>"},{"location":"api/interfaces/serial_connection/","title":"Serial Connection","text":""},{"location":"api/interfaces/serial_connection/#src.bioexperiment_suite.interfaces.serial_connection.SerialConnection","title":"<code>SerialConnection</code>","text":"<p>Class to handle serial communication with a device connected to a serial port.</p> Source code in <code>src/bioexperiment_suite/interfaces/serial_connection.py</code> <pre><code>class SerialConnection:\n    \"\"\"Class to handle serial communication with a device connected to a serial port.\"\"\"\n\n    def __init__(self, port: str, baudrate: int = 9600, timeout_sec: float = 1.0):\n        \"\"\"Initializes the serial connection object.\n\n        :param port: The serial port to connect to\n        :param baudrate: The baudrate of the serial connection. Defaults to 9600\n        :param timeout_sec: The timeout of the serial connection to respond in seconds. Defaults to 1.0\n\n        :raises serial.SerialException: If the serial connection cannot be established\n        \"\"\"\n        self.port = port\n        self.baudrate = baudrate\n        self.timeout_sec = timeout_sec\n        self._create_serial_connection()\n\n    def _create_serial_connection(self):\n        \"\"\"Creates a serial connection with the specified parameters.\"\"\"\n        self.serial = serial.Serial(self.port, self.baudrate, timeout=self.timeout_sec)\n        logger.info(f\"Serial connection established with {self.port}\")\n        sleep(3)\n\n    @staticmethod\n    def _restore_connection(method: Callable) -&gt; Callable:\n        \"\"\"Decorator to restore the serial connection if it is lost during communication.\n\n        :param method: The method to decorate\n\n        :returns: The decorated method\n        \"\"\"\n\n        @wraps(method)\n        def wrapper(self, *args, **kwargs):\n            try:\n                return method(self, *args, **kwargs)\n            except serial.SerialException:\n                logger.warning(f\"Serial connection lost on port {self.port}. Restoring connection...\")\n                self._create_serial_connection()\n                return method(self, *args, **kwargs)\n\n        return wrapper\n\n    @_restore_connection\n    def write_to_serial_port(self, data_to_send: list[int]) -&gt; None:\n        \"\"\"Writes data to the serial port.\n\n        :param data_to_send: The data to send to the serial port\n        \"\"\"\n        bytes_to_send = bytes(data_to_send)\n        self.serial.write(bytes_to_send)\n        logger.debug(f\"Data sent to serial port: {data_to_send}\")\n\n    @_restore_connection\n    def read_from_serial_port(self, response_bytes: int) -&gt; bytes:\n        \"\"\"Reads data from the serial port.\n\n        :param response_bytes: The number of bytes to read from the serial port\n\n        :returns: The response from the serial port\n        \"\"\"\n        response = self.serial.read(response_bytes)\n        logger.debug(f\"Data received from serial port: {list(response)}\")\n        return response\n\n    def communicate_with_serial_port(self, data_to_send: list[int], response_bytes: int) -&gt; bytes:\n        \"\"\"Communicates with the serial port by sending data and receiving a response.\n\n        :param data_to_send: The data to send to the serial port\n        :param response_bytes: The number of bytes to read from the serial port as a response\n\n        :returns: The response from the serial port\n        \"\"\"\n        self.write_to_serial_port(data_to_send)\n        response = self.read_from_serial_port(response_bytes)\n        return response\n\n    def _bytes_to_int(self, bytes_: bytes) -&gt; int:\n        \"\"\"Converts a byte array to an integer.\n\n        :param bytes_: The byte array to convert to an integer\n\n        :returns: The integer representation of the byte array\n        \"\"\"\n        return int.from_bytes(bytes_, byteorder=\"big\")\n\n    def _int_to_bytes(self, integer: int, n_bytes: int | None = None) -&gt; list[int]:\n        \"\"\"Converts an integer to a byte array.\n\n        :param integer: The integer to convert to a byte array\n        :param n_bytes: The number of bytes to represent the integer. Defaults to None.\n\n        :returns: The byte array representation of the integer\n        \"\"\"\n        if n_bytes is None:\n            n_bytes = (integer.bit_length() + 7) // 8\n\n        byte_representation = integer.to_bytes(n_bytes, byteorder=\"big\")\n        return list(byte_representation)\n\n    def __del__(self):\n        \"\"\"Closes the serial connection when the object is deleted.\"\"\"\n        logger.debug(f\"Closing serial connection with {self.port}\")\n        self.serial.close()\n</code></pre>"},{"location":"api/interfaces/serial_connection/#src.bioexperiment_suite.interfaces.serial_connection.SerialConnection.__init__","title":"<code>__init__(port, baudrate=9600, timeout_sec=1.0)</code>","text":"<p>Initializes the serial connection object.</p> <p>Parameters:</p> Name Type Description Default <code>port</code> <code>str</code> <p>The serial port to connect to</p> required <code>baudrate</code> <code>int</code> <p>The baudrate of the serial connection. Defaults to 9600</p> <code>9600</code> <code>timeout_sec</code> <code>float</code> <p>The timeout of the serial connection to respond in seconds. Defaults to 1.0</p> <code>1.0</code> <p>Raises:</p> Type Description <code>serial.SerialException</code> <p>If the serial connection cannot be established</p> Source code in <code>src/bioexperiment_suite/interfaces/serial_connection.py</code> <pre><code>def __init__(self, port: str, baudrate: int = 9600, timeout_sec: float = 1.0):\n    \"\"\"Initializes the serial connection object.\n\n    :param port: The serial port to connect to\n    :param baudrate: The baudrate of the serial connection. Defaults to 9600\n    :param timeout_sec: The timeout of the serial connection to respond in seconds. Defaults to 1.0\n\n    :raises serial.SerialException: If the serial connection cannot be established\n    \"\"\"\n    self.port = port\n    self.baudrate = baudrate\n    self.timeout_sec = timeout_sec\n    self._create_serial_connection()\n</code></pre>"},{"location":"api/interfaces/serial_connection/#src.bioexperiment_suite.interfaces.serial_connection.SerialConnection.write_to_serial_port","title":"<code>write_to_serial_port(data_to_send)</code>","text":"<p>Writes data to the serial port.</p> <p>Parameters:</p> Name Type Description Default <code>data_to_send</code> <code>list[int]</code> <p>The data to send to the serial port</p> required Source code in <code>src/bioexperiment_suite/interfaces/serial_connection.py</code> <pre><code>@_restore_connection\ndef write_to_serial_port(self, data_to_send: list[int]) -&gt; None:\n    \"\"\"Writes data to the serial port.\n\n    :param data_to_send: The data to send to the serial port\n    \"\"\"\n    bytes_to_send = bytes(data_to_send)\n    self.serial.write(bytes_to_send)\n    logger.debug(f\"Data sent to serial port: {data_to_send}\")\n</code></pre>"},{"location":"api/interfaces/serial_connection/#src.bioexperiment_suite.interfaces.serial_connection.SerialConnection.read_from_serial_port","title":"<code>read_from_serial_port(response_bytes)</code>","text":"<p>Reads data from the serial port.</p> <p>Parameters:</p> Name Type Description Default <code>response_bytes</code> <code>int</code> <p>The number of bytes to read from the serial port</p> required <p>Returns:</p> Type Description <code>bytes</code> <p>The response from the serial port</p> Source code in <code>src/bioexperiment_suite/interfaces/serial_connection.py</code> <pre><code>@_restore_connection\ndef read_from_serial_port(self, response_bytes: int) -&gt; bytes:\n    \"\"\"Reads data from the serial port.\n\n    :param response_bytes: The number of bytes to read from the serial port\n\n    :returns: The response from the serial port\n    \"\"\"\n    response = self.serial.read(response_bytes)\n    logger.debug(f\"Data received from serial port: {list(response)}\")\n    return response\n</code></pre>"},{"location":"api/interfaces/serial_connection/#src.bioexperiment_suite.interfaces.serial_connection.SerialConnection.communicate_with_serial_port","title":"<code>communicate_with_serial_port(data_to_send, response_bytes)</code>","text":"<p>Communicates with the serial port by sending data and receiving a response.</p> <p>Parameters:</p> Name Type Description Default <code>data_to_send</code> <code>list[int]</code> <p>The data to send to the serial port</p> required <code>response_bytes</code> <code>int</code> <p>The number of bytes to read from the serial port as a response</p> required <p>Returns:</p> Type Description <code>bytes</code> <p>The response from the serial port</p> Source code in <code>src/bioexperiment_suite/interfaces/serial_connection.py</code> <pre><code>def communicate_with_serial_port(self, data_to_send: list[int], response_bytes: int) -&gt; bytes:\n    \"\"\"Communicates with the serial port by sending data and receiving a response.\n\n    :param data_to_send: The data to send to the serial port\n    :param response_bytes: The number of bytes to read from the serial port as a response\n\n    :returns: The response from the serial port\n    \"\"\"\n    self.write_to_serial_port(data_to_send)\n    response = self.read_from_serial_port(response_bytes)\n    return response\n</code></pre>"},{"location":"api/interfaces/serial_connection/#src.bioexperiment_suite.interfaces.serial_connection.SerialConnection.__del__","title":"<code>__del__()</code>","text":"<p>Closes the serial connection when the object is deleted.</p> Source code in <code>src/bioexperiment_suite/interfaces/serial_connection.py</code> <pre><code>def __del__(self):\n    \"\"\"Closes the serial connection when the object is deleted.\"\"\"\n    logger.debug(f\"Closing serial connection with {self.port}\")\n    self.serial.close()\n</code></pre>"},{"location":"api/interfaces/spectrophotometer/","title":"Spectrophotometer","text":""},{"location":"api/interfaces/spectrophotometer/#src.bioexperiment_suite.interfaces.spectrophotometer.Spectrophotometer","title":"<code>Spectrophotometer</code>","text":"<p>               Bases: <code>SerialConnection</code></p> <p>Class to handle communication with a spectrophotometer connected to a serial port.</p> Source code in <code>src/bioexperiment_suite/interfaces/spectrophotometer.py</code> <pre><code>class Spectrophotometer(SerialConnection):\n    \"\"\"Class to handle communication with a spectrophotometer connected to a serial port.\"\"\"\n\n    def __init__(self, port: str, baudrate: int = 9600, timeout_sec: int | float = 1.0):\n        \"\"\"Initializes the spectrophotometer object.\n\n        :param port: The serial port to connect to\n        :param baudrate: The baudrate of the serial connection. Defaults to 9600\n        :param timeout_sec: The timeout of the serial connection to respond in seconds. Defaults to 1.0\n        \"\"\"\n        self.interface = device_interfaces.spectrophotometer\n        super(Spectrophotometer, self).__init__(port, baudrate, timeout_sec)\n\n    def get_temperature(self) -&gt; float:\n        \"\"\"Gets the temperature of the spectrophotometer\n\n        :returns: The temperature in degrees Celsius\n        \"\"\"\n        logger.debug(\"Getting temperature\")\n        temperature_response = self.communicate_with_serial_port(\n            self.interface.commands.get_temperature.request,\n            self.interface.commands.get_temperature.response_len,\n        )\n        logger.debug(f\"Temperature response: {list(temperature_response)}\")\n        integer, fractional = temperature_response[2:]\n        temperature = integer + (fractional / 100)\n        return temperature\n\n    def _send_start_measurement_command(self):\n        \"\"\"Sends the command to start the measurement.\"\"\"\n        self.write_to_serial_port(self.interface.commands.start_measurement.request)\n        logger.debug(\"Start measurement command sent\")\n\n    def _get_absorbance(self) -&gt; float | None:\n        \"\"\"Gets the absorbance of the sample.\n\n        :returns: The absorbance of the sample\n        \"\"\"\n        logger.debug(\"Getting absorbance\")\n        absorbance_response = self.communicate_with_serial_port(\n            self.interface.commands.get_measurement_result.request,\n            self.interface.commands.get_measurement_result.response_len,\n        )\n        logger.debug(f\"Absorbance response: {list(absorbance_response)}\")\n        if not absorbance_response:\n            return None\n        integer, fractional = absorbance_response[2:]\n        absorbance = integer + (fractional / 100)\n        logger.debug(f\"Absorbance: {absorbance}\")\n        return absorbance\n\n    def measure_absorbance(self) -&gt; float:\n        \"\"\"Measures the absorbance of the sample.\n\n        :returns: The absorbance of the sample\n        \"\"\"\n        logger.debug(\"Measuring absorbance\")\n        self._send_start_measurement_command()\n        logger.debug(\"Absorbance not ready yet, waiting...\")\n        sleep(4)\n        absorbance = self._get_absorbance()\n        if absorbance is None:\n            logger.error(\"Absorbance could not be measured\")\n            raise Exception(\"Absorbance could not be measured\")\n\n        return absorbance\n</code></pre>"},{"location":"api/interfaces/spectrophotometer/#src.bioexperiment_suite.interfaces.spectrophotometer.Spectrophotometer.__init__","title":"<code>__init__(port, baudrate=9600, timeout_sec=1.0)</code>","text":"<p>Initializes the spectrophotometer object.</p> <p>Parameters:</p> Name Type Description Default <code>port</code> <code>str</code> <p>The serial port to connect to</p> required <code>baudrate</code> <code>int</code> <p>The baudrate of the serial connection. Defaults to 9600</p> <code>9600</code> <code>timeout_sec</code> <code>int | float</code> <p>The timeout of the serial connection to respond in seconds. Defaults to 1.0</p> <code>1.0</code> Source code in <code>src/bioexperiment_suite/interfaces/spectrophotometer.py</code> <pre><code>def __init__(self, port: str, baudrate: int = 9600, timeout_sec: int | float = 1.0):\n    \"\"\"Initializes the spectrophotometer object.\n\n    :param port: The serial port to connect to\n    :param baudrate: The baudrate of the serial connection. Defaults to 9600\n    :param timeout_sec: The timeout of the serial connection to respond in seconds. Defaults to 1.0\n    \"\"\"\n    self.interface = device_interfaces.spectrophotometer\n    super(Spectrophotometer, self).__init__(port, baudrate, timeout_sec)\n</code></pre>"},{"location":"api/interfaces/spectrophotometer/#src.bioexperiment_suite.interfaces.spectrophotometer.Spectrophotometer.get_temperature","title":"<code>get_temperature()</code>","text":"<p>Gets the temperature of the spectrophotometer</p> <p>Returns:</p> Type Description <code>float</code> <p>The temperature in degrees Celsius</p> Source code in <code>src/bioexperiment_suite/interfaces/spectrophotometer.py</code> <pre><code>def get_temperature(self) -&gt; float:\n    \"\"\"Gets the temperature of the spectrophotometer\n\n    :returns: The temperature in degrees Celsius\n    \"\"\"\n    logger.debug(\"Getting temperature\")\n    temperature_response = self.communicate_with_serial_port(\n        self.interface.commands.get_temperature.request,\n        self.interface.commands.get_temperature.response_len,\n    )\n    logger.debug(f\"Temperature response: {list(temperature_response)}\")\n    integer, fractional = temperature_response[2:]\n    temperature = integer + (fractional / 100)\n    return temperature\n</code></pre>"},{"location":"api/interfaces/spectrophotometer/#src.bioexperiment_suite.interfaces.spectrophotometer.Spectrophotometer.measure_absorbance","title":"<code>measure_absorbance()</code>","text":"<p>Measures the absorbance of the sample.</p> <p>Returns:</p> Type Description <code>float</code> <p>The absorbance of the sample</p> Source code in <code>src/bioexperiment_suite/interfaces/spectrophotometer.py</code> <pre><code>def measure_absorbance(self) -&gt; float:\n    \"\"\"Measures the absorbance of the sample.\n\n    :returns: The absorbance of the sample\n    \"\"\"\n    logger.debug(\"Measuring absorbance\")\n    self._send_start_measurement_command()\n    logger.debug(\"Absorbance not ready yet, waiting...\")\n    sleep(4)\n    absorbance = self._get_absorbance()\n    if absorbance is None:\n        logger.error(\"Absorbance could not be measured\")\n        raise Exception(\"Absorbance could not be measured\")\n\n    return absorbance\n</code></pre>"},{"location":"examples/","title":"Examples","text":"<p>This is a collection of examples that demonstrate how to use the various features of the BioExperiment Suite. It will guide you through the process of using the API to perform common tasks in such order:</p>"}]}